<!DOCTYPE html>
<html lang="en">

<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <style>

        </style>
</head>

<body>
        <h1 id="heading">Hello friends, Let's get Wild!</h1>
        <button id="stop">Stop</button>
        <button id="start">Start</button>
</body>
<script>

        // This function generates a random hexadecimal color code.
        const randomHexColor = () => {
                // This string contains all the possible characters that can appear in a color code.
                let letters = "0123456789ABCDEF";

                // A color code starts with '#'.
                let color = '#';

                // A color code has 6 characters after the '#'. This loop generates each of these characters.
                for (let i = 0; i < 6; i++)
                        // Math.random generates a random number between 0 and 1, which is then multiplied by 16 (the number of possible characters) and rounded down to the nearest whole number. This index is used to pick a character from the 'letters' string.
                        color += letters[(Math.floor(Math.random() * 16))];
                //Math.random() * 16: Math.random() generates a random floating-point number between 0 (inclusive) and 1 (exclusive). This number is then multiplied by 16, resulting in a random floating-point number between 0 (inclusive) and 16 (exclusive).

                // Math.floor(Math.random() * 16): Math.floor() rounds down the result from step 1 to the nearest whole number. This gives a random integer between 0 (inclusive) and 15 (inclusive).

                // letters[(Math.floor(Math.random() * 16))]: This uses the random integer from step 2 as an index to select a character from the letters string. Since the letters string contains all the characters that can appear in a hexadecimal color code (0-9 and A-F), this gives a random hexadecimal digit.

                // color += letters[(Math.floor(Math.random() * 16))];: This adds the random hexadecimal digit from step 3 to the color string.

                // This process is repeated 6 times by the loop, resulting in a string of 6 random hexadecimal digits. When combined with the '#' that was added to color before the loop, this gives a random hexadecimal color code. 

                // The generated color code is logged to the console.
                console.log(color);

                // The generated color code is returned from the function.
                return color;
        }

        // The <body> element of the page is selected.
        const background = document.querySelector("body");

        // This function changes the background color of the page to a random color.
        let colorChange = () => {
                // The background color of the page is set to a random color generated by the 'randomHexColor' function.
                background.style.backgroundColor = randomHexColor();
        }

        // An interval is set to change the background color of the page every 1000 milliseconds (or 1 second).
        let changeMe = setInterval(colorChange, 1000);

        // The 'stop' button is selected.
        const stop = document.getElementById("stop");

        // An event listener is added to the 'stop' button to stop changing the background color when the button is clicked.
        stop.addEventListener("click", function () {
                // The interval is cleared, stopping the background color from changing.
                clearInterval(changeMe);
                changeMe = null;
                //Yes, it is a good practice to clear an interval and set its reference to null when it's no longer needed. This is especially important in larger applications where memory management is a concern.

                // Clearing the interval with clearInterval(changeMe); ensures that the function will not be called again in the future, freeing up system resources.

                // Setting changeMe = null; after clearing the interval is a good practice because it explicitly indicates that the interval is no longer in use. This can help prevent bugs that could occur if you accidentally try to clear the same interval again later.

                // However, it's important to note that setting changeMe = null; does not automatically clear the interval. The clearInterval() function must be called before setting the interval reference to null.

                // A message is logged to the console.
                console.log("Stopped!");
        });

        // The 'start' button is selected.
        const start = document.getElementById("start");

        // An event listener is added to the 'start' button to start changing the background color when the button is clicked.
        start.addEventListener("click", function () {
                // A message is logged to the console.
                console.log("Started!");
                // An interval is set to change the background color of the page every 1000 milliseconds (or 1 second).
                if (!changeMe) {
                        changeMe = setInterval(colorChange, 1000);
                }
                // This code checks if changeMe is falsy (which includes null, undefined, 0, NaN, an empty string, and of course, false). If changeMe is falsy, it starts a new interval that calls the colorChange function every 1000 milliseconds (or 1 second), and assigns the ID of this interval to changeMe.

                // This is a good practice if you want to ensure that only one interval is running at a time. If changeMe already has a value (meaning an interval is already running), this code will not start a new interval. If changeMe does not have a value (meaning no interval is currently running), this code will start a new interval.

        });

</script>

</html>